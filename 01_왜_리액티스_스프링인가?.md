# 01 왜 리액티브 스프링인가?

## 왜 리액티브인가?
앞으로 자주 마주할 용어이기도 하고 알아두면 똑똑한 척 할 수 있으니깐...
- `탄력성` https://www.reactivemanifesto.org/ko/glossary#Elasticity
- `장애` https://www.reactivemanifesto.org/ko/glossary#Failure
- `분리` https://www.reactivemanifesto.org/ko/glossary#Isolation
- `컴포넌트` https://www.reactivemanifesto.org/ko/glossary#Component

그러니까, 시스템이 유연하고 탄력적이고 회복성을 가지고 응답률을 높이는 것이 답이지, 물리적인 Scale-Out 을 한다고 될 일이 아니란 말씀이네요.

## 메세지 기반 통신
비동기 [Non-Blocking](https://www.reactivemanifesto.org/ko/glossary#Non-Blocking) 모델의 적절한 예시를 설명 잘 해 주셨네요.
> 우리는 현실에서 문자메세지(SMS 또는 이메일)을 보내면, 답장이 올 때까지 다른 일을 한다는 거죠.
> 답장이 오면 그 때 다시 문자메세지에 집중할 뿐이고요.

서비스 간에 통신할 때 자원을 효율적으로 사용하기 위해서는 [메세지 기반(Message-Driven)](https://www.reactivemanifesto.org/ko/glossary#Message-Driven) 통신 원칙을 따르라고 하네요.
![img.png](.images/img.png)  
분산시스템으로 구현되는 모든 비즈니스의 핵심 가치는 응답성이라고 하요.
> Lightbend 의 Jonas Boner 님께서 (일단 모르는 사람) 리액티브 선언문이 얼마나 중요한지 말씀하셨대요.  
> [https://www.lightbend.com/blog/why_do_we_need_a_reactive_manifesto](https://www.lightbend.com/blog/why_do_we_need_a_reactive_manifesto)

## 반응성에 대한 유스케이스
~~그림이 복잡해서 그릴 수가 없네요~~  
아무튼 **스트리밍(Streaming)** 아키텍처라는게 있는데요, __데이터 처리 및 변환 흐름을 만드는 것__ 을 말한다고 해요.  
가용성 높은 시스템. 그러니깐 짧은 지연 시간과 높은 처리량을 위해서 [배압(Back-Pressure)](https://www.reactivemanifesto.org/ko/glossary#Back-Pressure) 처리가 잘 돼야 한다고 하는데... ~~글쓴이가 개연성이 좀 떨어지는 글을 쓰는 듯~~  

## 왜 리액티브 스프링인가?
리액티브 프레임워크로 `Akka` 는 Scala 쪽에 영향력이 크고 `Vert.X` 는 Node.js 를 겨냥해 논블로킹 과 이벤트 기반으로 설계 됐지만 호응이 없었다네요.

## 서비스 레벨에서의 반응
> 큰 시스템은 더 작은 규모의 시스템으로 구성되기 때문에 구성 요소의 리액티브 특성에 의존합니다. 즉,
> 리액티브 시스템은 설계 원칙을 적용하고, 이 특성을 모든 규모에 적용해 그 구성 요소를 합성 할 수 있게 하는 것을 의마합니다.
> - [리액티브 선언문](https://www.reactivemanifesto.org/ko) 중  

좋은 말인것 같기도 하고요. 암튼, 자바는 보편적으로 **명령형 프로그래밍(imperative programming)** 인데 이것의 문제를 확인 해보아요.
```java
interface ShoppingCartService {
  Output calculate(Input value);
}
```
```java
class OderService {
  private final ShoppingCartService service;
  
  void process() {
    Input input = genrateSomething();
    Output output = service.calculate(input);
  }
}
```
위의 코드를 설명해보면,
1. `ShoppingCartService` 가 있고요,
2. `OrderService` 는 `ShoppingCartService` 에 의존하고,
3. `OrderService.process()` 에서 `ShoppingCartService.calculate(Input)` 을 호출하게 돼 있어요.

문제는 `ShoppingCartService.calculate(Input)` 에서 DB 조회나 I/O 작업이 걸리면 동기화가 되면서 스레드가 잠기는거죠.  
이걸 콜백 기법으로 해결하면,
```java
interface ShoppingCartService {
  void calculate(Input input, Consumer<Output> output);
}
```
```java
class OrderService {
  private final ShoppingCartService service;
  
  void process() {
    Input input = genrateSomething();
    service.calculate(input, output -> {
      // implementation
    });
  }
}
```

`void calculate(Input, Consume<Output>)` 으로 바껴서 `Consume<Output>` 을 콜백으로 받아서 처리해요.

이 구조에서 `ShoppingCartService` 를 동기, 비동기로 각각 구현한다면,
```java
class SyncShoppingCartService implements ShoppingCartService {
  public void calculate(Input input, Consume<Output> output) {
    
  }
}
```
